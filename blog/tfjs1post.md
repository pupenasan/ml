# Browser-based Models with TensorFlow.js

## Тиждень 1

2.07.2023

Після спеціалізації DeepLearning.AI TensorFlow Developer вирішив продовжити навчання по програмі TensorFlow: Data and Deployment, де також 4 курси. На скільки я зрозумів, у цих курсах буде більше про використання вже навчених моделей (розгортання) замість тренування, як це було на курсах першої спеціалізації. Хоча по факту поки змінилося лише середовище розроблення - JS замість Python, і ми знову тренуємо моделі на tf але з особливостями в js. Принаймні так було першого тижня першого курсу https://www.coursera.org/learn/browser-based-models-tensorflow.

Тепер трохи деталей по тижню. Розглядали можливості використання бібліотеку tf в js в середовищі браузера. Розглянули арїхітектуру TensorFlow.js, який включає API рівнів Keras, під ним Core API TF (робота зі збереженими в файлах моделями), який у свою чергу може використовувати браузери з WebGL, або Node.js з відповідними доступними ресурсами. На першій лабі робили прогу в JS що є частиною HTML для створення та тренування простої моделі з одним шаром що має один нейрон (лінійна регресія). Дуже схоже на те як це робилося в Python, адже лібра та сама. Однак з'явилися і певні відмінності. У Python є вбудована бібліотека NumPy, яка забезпечує швидку роботу з масивами. У tf для JS натомість використовуються окремі методи, наприклад Tensor2D. Другою відмінністю є використання асинхронних функцій, щоб при тренуванні програма не зависала. Крім того у функції зворотного виклику методу тренування fit вказували виведення проміжних результатів на консоль браузера. А далі звісно ще якісь нюанси в синтаксисі, які не дуже то і розкрили (трохи скривлена незадовлено рожиця). 

Перший тест був неочікувано (після привички 1-ї сертифікатної програми) посеред тижня. Мене здивували відповіді на питання про API, які, як на мене, не відповідали варіантам в лекції. 

Далі розглядали вже тренування моделі класифікації ірисів за різними параметрами. Розглядали як працювати з tf.csv, як використовувати методи `map` та перетворення об'єктів в масиви у js.  Потім був ще один маленький тест по факту на розуміння деяких основ js . Якщо Ви до сих пір не знайомилися з асинхронними функціями і промісами в JS, то варто приділити цьому трохи (навіть достатньо) уваги. Знання основ JS з синхронними викликами тут малувато.  

Друга лаба вже була з побудовою моделі з кількома шарами. При цьому використовувалися дані CSV. Підстава лабораторки в тому, що доповнення до Chrome, яке там пропонується для Web Server вже не підтримується з кінця 2022-го, а в курсі нічого про це не сказано. Мінус в карму. Тільки в форумі спільноти вдалося знайти як з цим боротися, редактор Brackets вже має вбудоване використання на базі ноди. Вирішив навести деякі замітки для тих, хто зіткнувся з такою проблемою - https://github.com/pupenasan/ml/blob/main/blog/jstf_labs.md. Думаю далі буду їх нарощувати.

Лаба на оцінювання для мене далася не просто. Хоч цей курс базується на попередньому, є багато нюансів, пов'язаних з реалізацією бібліотеки для js. І хоч в лекціях про це трохи було, цього було не достатньо, щоб їх вистачало навіть для реалізації цієї лаби. Готовтеся, що треба реально вчитися самому, курс варто сприймати як путівник, принаймні так було перший тиждень. 

## Тиждень 2

8.07.2023

Другий тиждень курсу https://www.coursera.org/learn/browser-based-models-tensorflow. На цьому тижні вже тренували глибоку нейронку з кількома щільними та згортковими шарами. Вчилися використовувати бібліотеку tfjs-vis, яка забезпечує візуалізацію даних тренування. Для цього у функцію тренування fit у якості функції зворотного виклику вказується функція відображення, куди передаються метрики та назва контейнеру, куди їх виводити в HTML. Також розглядали підхід завантаження рисунків у вигляді спрайтів, коли усі рисунки об'єднуються в один великий, що збільшує швидкість, за рахунок зменшення кількості запитів. Для перетворення цього завантаження в потрібні тензори використовується tf.tidy, який крім того вичищає пам'ять від цих рисунків та проміжних тензорів. Все подивилися на лабі, яку потім скопіпастив частинами в тестове завдання.      

## Тиждень 3

13.07.2023

Пройшов третій тиждень курсу https://www.coursera.org/learn/browser-based-models-tensorflow. Цього тижня вчилися використовувати в JS на стороні фронтенду вже натреновані готові моделі для прогнозування. Почали з готових моделей в репозиторії TensorFlow.js models звідси https://github.com/tensorflow/tfjs-models. Ці моделі вже готові для використання в TensorFlow.js, і на скільки я зрозумів, більше призначені для навчальних цілей, ніж для реального використання. Спочатку гралися з моделлю Toxicity Classifier, яка визначала ймовірності "токсичності" тексту і в чому саме ця токсичність. Далі гралися з MobileNet, який визначав що саме зображено на рисунку (всього 1000 міток і відповідно варіантів вибору). Використання дуже просте - просто завантажуємо модель як бібліотечний елемент, а далі справа в синтаксисі. Більш цінним для мене є інший кейс - передача моделі від Keras Python до TensorFlow.js, так як такий підхід коли вчимо в python а юзаємо в js, - це саме те, що мені потрібно. Нагадаю, що ідея в тому, щоб юзати готові модельки в Node-RED (а може я про це забув сказати раніше :) ). Так от, для такого конвертування є спеціальна тулза, яку можна запустити і перетворити файли H5 в JSON+BIN. На лабах це робили на найпростішій моделі регресії, в завданні на оцінювання - для класифікації на котів та собак (тільки для створення моделі). 

Щодо задачі на оцінювання - це ще був той челендж. Почалося з того, що в хмарному Колабі Python не захотів розархівувати файл, прийшлося розпакувати, знову запакувати і залити, і все наче б то запрацювало. Але прийшла інша проблема - моделі зроблені та конвертовані в новому tf вочевидь відрізняються від своїх попередників. А в завданні чітко було сказано версію, якою тре користуватися. Я проігнорив попередження, адже все запрацювало, ще й подумав про себе "невже все так просто?". Але... результати виконання завдання не були прийняті. І тут почалися танці з бубнами, такі звичні в світі пром. автоматизації, та і в ІТ. Отже вияснилося, що треба іншу версію Python, бо та що на Колабі, не підтримує tensorflow.js 2.2. Я задумав з льоту поставити нову версію на Google Colab і ... безкоштовна версія перестала допускати мене до GPU (слава Богу на наступний день шару вернули назад). Кількагодинні нагуглювання привели мене до того, що прийшлося почитати форум підтримки курсу (треба з самого початку було це зробити),  поставити локально на комп середовище conda, і пройти по методичці з поста форуму (кому цікаво ось мої замітки лінк <https://github.com/pupenasan/ml/blob/main/blog/jstf_labs.md#тиждень-3> ). Запустивши Jupiter і відповідний код я наглядно побачив що значить тренувати моделі без GPU! Це вийшло на стільки повільніше порівняно з тим що було в хмарному Colab, мабуть десь в 8 разів! Зробивши zip і відправивши на Coursera отримав залік. 

Багатогодинна робота зв'язана як завжди з купою тонкощів. Черговий камін в город розробників - відсутність супроводу курсу. Я  безкоштовно його проходжу, тому жалітися нічого. Але багато людей платять, і зустрічаються з такою невідповідністю. Працюємо далі, попереду ще купа роботи.        

## Тиждень 4

19.07.2023

Завершив 4-й тиждень і відповідно весь курс https://www.coursera.org/learn/browser-based-models-tensorflow за що отримав сертифікат https://www.coursera.org/account/accomplishments/verify/Y7V2TKLP85CJ. Цього тижня ми дотреновували існуючу модель для розпізнавання з камери компа що саме за жести показує людина: камінь, ножиці чи папір.   

Почали з того, що розглядали механізми доступу до камери з браузера. Для спрощення цього процесу використовувалася готова відкрита бібліотека у вигляді файлу webcam.js від розробників TensorFlow. З точки зору використання лібри все дуже просто, якщо користуєшся готовим прикладом. Вказуєш куди відображати зміст і за необхідності робиш знімки, які записуєш в змінну з даними. 

Потім розглянули як завантажити вже навчену мережу щоб потім її донавчити. Використовували напереднавчену модель класифікації зображень MobileNet https://www.tensorflow.org/api_docs/python/tf/keras/applications/mobilenet/MobileNet . На відміну від підходу, який використовували в попередніх курсах на Python, тут не змінювали навчену модель, а по факту використовували вихід одного з її шарів. Тобто замість заморожування шарів навченої моделі, ми її "обрізали" на верхніх шарах, а її виходи, тобто по факту прогнози верхнього шару (в якихось там умовних одиницях) за поданими на вхід зображеннями подавали на нову модель в якості вхідних даних. Далі тренували саме цю нову модель, але вже відповідно не за зображеннями, а за прогнозами попередньої моделі. Сподіваюсь зрозуміло висловився. 

Далі в лекціях розглядали рішення розпізнавання жестів камень-ножиці-папір, а на лабах це все попробували. Це мабуть сама практична лаба, з точки зору впровадження від початку до кінця: є збір даних, є тренування моделі, є використання результату. Сидиш перед камерою ноута і натискаєш кнопку з міткою повертаючи свою руку з жестом в різних ракурсах. Тут дуже яскраво відчувається ефект трнеування на великій кількості даних. Спочатку тренував на 20 зображеннях для кожної мітки - результат був дуже поганий. Більш менш нормальне розпізнавання пішло з 50 зображень. Варто зауважити, що модель тренувалася дуже швидко - менше хвилини. Думаю, якби її наростити, ще збільшити кількість зображень то результат був би ще кращий. Ця лаба могла б слугувати "швидким стартом в машинне навчання", де можна швидко показати всі процеси від початку до кінця кейсу розпізнавання зображення. Так звісно, при цьому багато чого буде приховано під капотом, але навіть ці результати можна кастомізувати під себе. Це дійсно може "заразити" людей машинним навчанням шляхом швидкого входження в тему на цікавих прикладах. За це від мене великий плюс в карму розробників курсу!

Щодо перевірки теорії - нічого особливого. А ось на тестовому завданні мене чекав неприємний сюрприз. Завдання, по суті, було саме по собі простим - добавити до камень-ножиці-папір ще жест ящірки та Спока (заодно дізнався що це за жест, бо до цього думав що це невідома тваринка :) ). Але вже при добавленні рисунків прога в браузері почала крешитися. Виявилося, що потрібно багато оперативної пам'яті і мій ноут просто вже застарів для таких речей. Дякуючи хорошому другу, комп якого я використав, вдалося таки натренувати модель на потрібний результат. Описав це в замітках до лаб  https://github.com/pupenasan/ml/blob/main/blog/jstf_labs.md 

Зрезюмую усі чотири тижні. Не дивлячись на зауваження з відсутністю оновлення матеріалів курсу, які писав раніше, даний курс реально має відчутну практичну цінність. Це вже не просто про те, як створювати і тренувати моделі, а про те - як це все вже використовувати. Тим не менше, вони базуються на чотирьох курсах з попередньої спеціалізації. Попереду ще три цікавих курси, де буде про імплементацію для смартфонів та Edge-пристроїв, але мабуть варто трохи зробити паузу, бо є ще багато іншої роботи.         

Усю історію постів проходження по курсам тематики ML можна почитати тут https://github.com/pupenasan/ml/tree/main/blog
